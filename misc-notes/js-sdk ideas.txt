//////////////////// The SDK


availableContentTypes = ['json', 'xml', 'xsd', 'csv', 'html'];

//...


//////////////////// Usage


// Instantiate
slashdb = SlashDB(
  host='http://demo.slashdb.com',
  config={
    'apikey': '',
    'jwt': '' // ??
  }
);

// Setup default
slashdb.configure(
  {
    'apikey': '',
    'jwt': '',
    'wildcard': '*', 
    'separator': ',', 
    'wantarray': true,

    'contentType': 'json'
  }
);


/*

Data Discovery

- pick database and table
- filtering exact value, range, AND, OR, wildcard, not
- following relations
- object/array/vector/scalar output
- output format
- authentication
- query string parameters: limit, offset, stream, href, 
    sort, distinct, depth, transpose, wantarray, wildcard, 
    separator, string substitution, 
  CSV: headers, csvNullStr
  JSON: href
  TXT: nil_visible
  XML: nil_visible, href
  XSD: cardinality
- encoding url
- creating multiple instances to connect to multiple slashdb services e.g. pull from slashdb1 and push to slashdb2
*/


// HTTP: GET http://demos.slashdb.com
//           /db/Chinook/Customers
//           /CustomerId/5,10/FirstName/Mark,Paul/BirthDate/1985-05-02..1986-05-02/LastName/C*
//           /FirstName,LastName,Company.json
//           ?sort=-Country&limit=10&offset=2&depth=1

/*
FAQ - Frequently Asked Queris

selet 
from Customers
where CustomerId = 5 OR FirstName = "Mark"
*/

// Get resources
// HTTP: GET http://demos.slashdb.com
//           /db/Chinook/Customers
//           /CustomerId/5,10/FirstName/Mark/BirthDate/1985-05-02..1986-05-02/LastName/C*
//           /Invoice
//           /InvoiceLine
//           /UnitPrice,Quantity.json
//           ?sort=Quantity&limit=10&offset=2&depth=1
slashdb
  .data_discovery(database='Chinook', resource='Customer', config={'wildcard': '*', 'separator': ',', })
  
  .configure({'wildcard': '*', 'separator': ',', })
  
  .filter(  // AND
    {
      'CustomerId': [5, 10],  // OR
      'FirstName': 'Mark',  // Exact
      'BirstDate': slashdb.between(['1985-05-02', '1985-05-02']),  // Range
      'LastName': 'C*'  // wildcard
    }
	

  )

  // traverse and filter 
  .traverse('Invoice')
  .filter(
    {
      'Total': slashdb.not(0.99)
    }
  )

  .traverse('InvoiceLine')
  .filter()
  
  // modifiers applicable to last context 
  .columns(['UnitPrice', 'Quantity'])
  .transpose()
  .sort(['Quantity'])
  .limit(10)
  .offset(2)
  .get(
    // optional
    contentType='json', stream=false, limit=null, offset=null, depth=1, wantarray=false, transpose=true
  )


// Update resources
// What about sending content type other than json? Payload as string? SDK could be used by NodeJS application that processes xml.

// Fixes Postal code for invoices of some customers
slashdb
  .data_discovery(database='Chinook', resourece='Customer', config={'wildcard': '*', 'separator': ',', })
  .filter(
    {
      'CustomerId': [5, 10]
    }
  )
  .traverse('Invoice')
  .filter(
    {
      'BillingCity': 'Prague'
    }
  )
  .update(
    contentType='json',
    payload={
      'BillingPostalCode': '14800'
    }
  )


// Create resources
// Filtering and traversing is possible but it would be better to disallow 
// to avoid confustion that new resources are somehow connected to the filtering result.

// Create new customer.
slashdb
  .data_discovery(database='Chinook', resourece='Customer', config={'wildcard': '*', 'separator': ',', })
  .create(
    {
      'CustomerId': 1000,
      'FirstName': 'Mike',
      'LastName': 'Dob'
      // ...
    }
  )


// Delete resources
// Delete some invoices from specific customer.
slashdb
  .data_discovery(database='Chinook', resourece='Customer', config={'wildcard': '*', 'separator': ','})
  .filter(
    {
      'CustomerId': [5, 10]
    }
  )
  .traverse('Invoice')
  .filter(
    {
      'BillingCity': 'Prague'
    }
  )
  .delete()



/////////////////////////


q = slashdb
  .data_discovery('Chinook', 'Customer')
  .filter()
  .query()

slashdb.get(q)
slashdb.put(q, {'City': 'Berlin'})
slashdb.delete(q)
slashdb.post({})

slashdb.data_discover('Chinook', 'Customer').create({'CustomerId': 1})

slashdb
  .data_discovery('Chinook', 'Customer')
  .put({'CustomerId': 1000, 'FirstName': 'Mike', 'LastName': 'Dob'})

dd.post()
dd.delete()





slsahdb
  .get('Chinook', 'Customers')
  .filter(CustomerId=[5, 10])                                         // OR
  .filter(FirstName='Mark')                                           // Exact
  .filter(BirstDate=slashdb.between(['1985-05-02', '1985-05-02']))    // Range
  .filter(LastName='C*')                                              // wildcard
  .format('json')                                                     // output format


  /* 
  
  SQL Pass-thru

  - parameterized query
  
  */


slashdb
  .sqlPassThru(query='customers-by-country')
  .execute(httpMethod='GET', parameters={'country': 'Germany'})



/* 

Internal API

User, query and database configurations.
License upload.

*/

AND - n col:val pairs, and joins together: col1:val1, col2:val2, col3:val3 => /col1/val1/col2/val2/col3/val3 etc
OR - 1 col, n val pairs, and joins together: col1:val1,val2,val3 => /col1/val1,val2,val3
NOT - 1 col, prepends with tilde: col1 => ~col1
RANGE - 1 col, <=, >=, or <= x <= : col1:lt(val1) => /col1/..val1 col1:gt(val1) => /col1/val1.. col1:between(val1,val2) => /col1/val1..val2

not = (colFilter) => { 
	if (colFilter == null || colFilter.length < 1) { return '' }
	return `~${colFilter}` 
}

any = (...values) => {
	
	if (values.length <= 1) { return '' }

	let s = null;
	for (const [i, v] of values.entries()) {
		if (v == null || v.length < 1) { return '' }
		s = i === 0 ? `${v}/` : s + `${v},`
	}
	
	return s.slice(0,-1)
}

eq = (col, value) => {
	return any(col, value);
}

and = (...colFilters) => {

	if (colFilters.length === 0) { return '' }

	let s = '';
	for (const f of colFilters) {
		if (f == null || f.length < 1) { return '' }
		s += `${f}/`
	}
	return s.slice(0,-1)
}

between = (col, lower = undefined, upper = undefined) => {
	if ( (lower || upper) === undefined || col.length < 1 || col == null) { return '' }	

	const lb = lower === undefined ? '' : lower;
	const ub = upper === undefined ? '' : upper;
	return `${col}/${lb}..${ub}`
}

gte = (col, lb) => {
	if ( col.length < 1 || col == null) { return '' }
	return between(col, lb)
}

lte = (col, ub) => {
	if ( col.length < 1 || col == null) { return '' }
	return between(col, undefined, ub)
}


and(or("CustomerId","5","10"),or("FirstName","Mark","Paul"),range("BirthDate", {gte:"1985-05-02",lte:"1986-05-2"}),not("LastName/C*"))

and(
	or("CustomerId","5","10"),
	or("FirstName","Mark","Paul"),
	range("BirthDate", {gte:"1985-05-02",lte:"1986-05-2"}),
	not("LastName/C*")
	)
	
class QueryBuilder {
	constructor(method,resource, filter = undefined) {
		if (!method) {
			throw new Error('method is undefined');
		}
		if (!resource) {
			throw new Error('resource is undefined');
		}
		
		this.method = method.toUpperCase();
		this.resources = new Set([resource]);
		this.filters = { [resource] : filter};
		this.currContext = resource;
	
		
		this.queryParams = {
			'sort' : undefined,
			'distinct' : undefined,
			'depth' : undefined
		};
	
		this.pathString = `/${resource}`;
		this.pathString += filter === undefined ? '' : `/${filter}`;
		
		this.fullQueryString = null;
		
		if (this.method !== "POST") {
			this.join = (resource) => { 
				this.pathString = `${this.pathString}/${resource}`; 
				this.resources.add(resource);
				this.currContext = resource;
				return this;
			}
		}
	}
	
	addFilter(filterString) {
		this.pathString += `/${filterString}`; 
		if (this.filters[this.currContext] === undefined) {
			this.filters[this.currContext] = `${filterString}`;
		}
		else {
			this.filters[this.currContext] += `/${filterString}`;
		}		
			
		return this;
	}
	
	sort(...columns) {
		let s = '';
		for (const col of columns) {
			s += `${col},`;
		}
		s = s.slice(0,s.length-1);
		this.queryParams['sort'] = s;
		return this;
	}
	
	distinct() {
		this.queryParams['distinct'] = 'distinct';
		return this;
	}
	
	depth(level) {
		this.queryParams['depth'] = level;
		return this;
	}
	
	createQuery() {
		let paramString = '';
		for (const p in this.queryParams) {
			console.log(p, this.queryParams[p])
			paramString += p !== undefined ? `${p}=${this.queryParams[p]}&` : '';
		}
		paramString = paramString.slice(0,paramString.length-1);
		this.fullQueryString = `${this.pathString}?${paramString}`;
		return this;
	}
}



